export type Maybe<T> = T | null;
export type InputMaybe<T> = T | Ref<T> | ComputedRef<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /**
   * Define a Relay Cursor type:
   * https://relay.dev/graphql/connections.htm#sec-Cursor
   */
  Cursor: any;
  Map: any;
  Time: any;
};

export type CodingStats = {
  __typename: 'CodingStats';
  calculatedDays: Scalars['Int'];
  languages?: Maybe<Array<LanguageStat>>;
  totalDuration: Scalars['String'];
  totalSeconds: Scalars['Int'];
};

/**
 * CreateLabelInput is used for create Label object.
 * Input was generated by ent.
 */
export type CreateLabelInput = {
  createTime?: InputMaybe<Scalars['Time']>;
  githubRepositoryIDs?: InputMaybe<Array<Scalars['ID']>>;
  name: Scalars['String'];
  postIDs?: InputMaybe<Array<Scalars['ID']>>;
  updateTime?: InputMaybe<Scalars['Time']>;
};

/**
 * CreatePostInput is used for create Post object.
 * Input was generated by ent.
 */
export type CreatePostInput = {
  content: Scalars['String'];
  createTime?: InputMaybe<Scalars['Time']>;
  labelIDs?: InputMaybe<Array<Scalars['ID']>>;
  public?: InputMaybe<Scalars['Boolean']>;
  publishedAt?: InputMaybe<Scalars['Time']>;
  slug: Scalars['String'];
  title: Scalars['String'];
  updateTime?: InputMaybe<Scalars['Time']>;
};

export type GithubEvent = Node & {
  __typename: 'GithubEvent';
  actor: GithubUser;
  actorID: Scalars['Int'];
  createdAt: Scalars['Time'];
  eventID: Scalars['String'];
  eventType: Scalars['String'];
  id: Scalars['ID'];
  payload: Scalars['Map'];
  public: Scalars['Boolean'];
  repo: GithubEventRepo;
  repoID: Scalars['Int'];
};

/** A connection to a list of items. */
export type GithubEventConnection = {
  __typename: 'GithubEventConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GithubEventEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GithubEventEdge = {
  __typename: 'GithubEventEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<GithubEvent>;
};

/** Ordering options for GithubEvent connections */
export type GithubEventOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order GithubEvents. */
  field: GithubEventOrderField;
};

/** Properties by which GithubEvent connections can be ordered. */
export enum GithubEventOrderField {
  ActorId = 'ACTOR_ID',
  CreatedAt = 'CREATED_AT',
  EventId = 'EVENT_ID',
  EventType = 'EVENT_TYPE',
  RepoId = 'REPO_ID'
}

export type GithubEventRepo = {
  __typename: 'GithubEventRepo';
  id: Scalars['Int'];
  name: Scalars['String'];
  url: Scalars['String'];
};

/**
 * GithubEventWhereInput is used for filtering GithubEvent objects.
 * Input was generated by ent.
 */
export type GithubEventWhereInput = {
  /** actor_id field predicates */
  actorID?: InputMaybe<Scalars['Int']>;
  actorIDGT?: InputMaybe<Scalars['Int']>;
  actorIDGTE?: InputMaybe<Scalars['Int']>;
  actorIDIn?: InputMaybe<Array<Scalars['Int']>>;
  actorIDLT?: InputMaybe<Scalars['Int']>;
  actorIDLTE?: InputMaybe<Scalars['Int']>;
  actorIDNEQ?: InputMaybe<Scalars['Int']>;
  actorIDNotIn?: InputMaybe<Array<Scalars['Int']>>;
  and?: InputMaybe<Array<GithubEventWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** event_id field predicates */
  eventID?: InputMaybe<Scalars['String']>;
  eventIDContains?: InputMaybe<Scalars['String']>;
  eventIDContainsFold?: InputMaybe<Scalars['String']>;
  eventIDEqualFold?: InputMaybe<Scalars['String']>;
  eventIDGT?: InputMaybe<Scalars['String']>;
  eventIDGTE?: InputMaybe<Scalars['String']>;
  eventIDHasPrefix?: InputMaybe<Scalars['String']>;
  eventIDHasSuffix?: InputMaybe<Scalars['String']>;
  eventIDIn?: InputMaybe<Array<Scalars['String']>>;
  eventIDLT?: InputMaybe<Scalars['String']>;
  eventIDLTE?: InputMaybe<Scalars['String']>;
  eventIDNEQ?: InputMaybe<Scalars['String']>;
  eventIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** event_type field predicates */
  eventType?: InputMaybe<Scalars['String']>;
  eventTypeContains?: InputMaybe<Scalars['String']>;
  eventTypeContainsFold?: InputMaybe<Scalars['String']>;
  eventTypeEqualFold?: InputMaybe<Scalars['String']>;
  eventTypeGT?: InputMaybe<Scalars['String']>;
  eventTypeGTE?: InputMaybe<Scalars['String']>;
  eventTypeHasPrefix?: InputMaybe<Scalars['String']>;
  eventTypeHasSuffix?: InputMaybe<Scalars['String']>;
  eventTypeIn?: InputMaybe<Array<Scalars['String']>>;
  eventTypeLT?: InputMaybe<Scalars['String']>;
  eventTypeLTE?: InputMaybe<Scalars['String']>;
  eventTypeNEQ?: InputMaybe<Scalars['String']>;
  eventTypeNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<GithubEventWhereInput>;
  or?: InputMaybe<Array<GithubEventWhereInput>>;
  /** public field predicates */
  public?: InputMaybe<Scalars['Boolean']>;
  publicNEQ?: InputMaybe<Scalars['Boolean']>;
  /** repo_id field predicates */
  repoID?: InputMaybe<Scalars['Int']>;
  repoIDGT?: InputMaybe<Scalars['Int']>;
  repoIDGTE?: InputMaybe<Scalars['Int']>;
  repoIDIn?: InputMaybe<Array<Scalars['Int']>>;
  repoIDLT?: InputMaybe<Scalars['Int']>;
  repoIDLTE?: InputMaybe<Scalars['Int']>;
  repoIDNEQ?: InputMaybe<Scalars['Int']>;
  repoIDNotIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type GithubLicense = {
  __typename: 'GithubLicense';
  htmlURL: Scalars['String'];
  key: Scalars['String'];
  name: Scalars['String'];
  spdxId?: Maybe<Scalars['String']>;
};

export type GithubRepository = Node & {
  __typename: 'GithubRepository';
  archived: Scalars['Boolean'];
  createdAt: Scalars['Time'];
  defaultBranch: Scalars['String'];
  description?: Maybe<Scalars['String']>;
  fork: Scalars['Boolean'];
  fullName: Scalars['String'];
  hasIssues: Scalars['Boolean'];
  homepage?: Maybe<Scalars['String']>;
  htmlURL: Scalars['String'];
  id: Scalars['ID'];
  isTemplate: Scalars['Boolean'];
  license?: Maybe<GithubLicense>;
  name: Scalars['String'];
  owner: GithubUser;
  ownerLogin: Scalars['String'];
  public: Scalars['Boolean'];
  pushedAt?: Maybe<Scalars['Time']>;
  repoID: Scalars['Int'];
  starCount: Scalars['Int'];
  updatedAt?: Maybe<Scalars['Time']>;
};

/** A connection to a list of items. */
export type GithubRepositoryConnection = {
  __typename: 'GithubRepositoryConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<GithubRepositoryEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type GithubRepositoryEdge = {
  __typename: 'GithubRepositoryEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<GithubRepository>;
};

/** Ordering options for GithubRepository connections */
export type GithubRepositoryOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order GithubRepositories. */
  field: GithubRepositoryOrderField;
};

/** Properties by which GithubRepository connections can be ordered. */
export enum GithubRepositoryOrderField {
  CreatedAt = 'CREATED_AT',
  FullName = 'FULL_NAME',
  Name = 'NAME',
  OwnerLogin = 'OWNER_LOGIN',
  PushedAt = 'PUSHED_AT',
  StarCount = 'STAR_COUNT',
  UpdatedAt = 'UPDATED_AT'
}

/**
 * GithubRepositoryWhereInput is used for filtering GithubRepository objects.
 * Input was generated by ent.
 */
export type GithubRepositoryWhereInput = {
  and?: InputMaybe<Array<GithubRepositoryWhereInput>>;
  /** archived field predicates */
  archived?: InputMaybe<Scalars['Boolean']>;
  archivedNEQ?: InputMaybe<Scalars['Boolean']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** default_branch field predicates */
  defaultBranch?: InputMaybe<Scalars['String']>;
  defaultBranchContains?: InputMaybe<Scalars['String']>;
  defaultBranchContainsFold?: InputMaybe<Scalars['String']>;
  defaultBranchEqualFold?: InputMaybe<Scalars['String']>;
  defaultBranchGT?: InputMaybe<Scalars['String']>;
  defaultBranchGTE?: InputMaybe<Scalars['String']>;
  defaultBranchHasPrefix?: InputMaybe<Scalars['String']>;
  defaultBranchHasSuffix?: InputMaybe<Scalars['String']>;
  defaultBranchIn?: InputMaybe<Array<Scalars['String']>>;
  defaultBranchLT?: InputMaybe<Scalars['String']>;
  defaultBranchLTE?: InputMaybe<Scalars['String']>;
  defaultBranchNEQ?: InputMaybe<Scalars['String']>;
  defaultBranchNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']>;
  descriptionContains?: InputMaybe<Scalars['String']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']>;
  descriptionGT?: InputMaybe<Scalars['String']>;
  descriptionGTE?: InputMaybe<Scalars['String']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']>;
  descriptionLT?: InputMaybe<Scalars['String']>;
  descriptionLTE?: InputMaybe<Scalars['String']>;
  descriptionNEQ?: InputMaybe<Scalars['String']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']>;
  /** fork field predicates */
  fork?: InputMaybe<Scalars['Boolean']>;
  forkNEQ?: InputMaybe<Scalars['Boolean']>;
  /** full_name field predicates */
  fullName?: InputMaybe<Scalars['String']>;
  fullNameContains?: InputMaybe<Scalars['String']>;
  fullNameContainsFold?: InputMaybe<Scalars['String']>;
  fullNameEqualFold?: InputMaybe<Scalars['String']>;
  fullNameGT?: InputMaybe<Scalars['String']>;
  fullNameGTE?: InputMaybe<Scalars['String']>;
  fullNameHasPrefix?: InputMaybe<Scalars['String']>;
  fullNameHasSuffix?: InputMaybe<Scalars['String']>;
  fullNameIn?: InputMaybe<Array<Scalars['String']>>;
  fullNameLT?: InputMaybe<Scalars['String']>;
  fullNameLTE?: InputMaybe<Scalars['String']>;
  fullNameNEQ?: InputMaybe<Scalars['String']>;
  fullNameNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** has_issues field predicates */
  hasIssues?: InputMaybe<Scalars['Boolean']>;
  hasIssuesNEQ?: InputMaybe<Scalars['Boolean']>;
  /** homepage field predicates */
  homepage?: InputMaybe<Scalars['String']>;
  homepageContains?: InputMaybe<Scalars['String']>;
  homepageContainsFold?: InputMaybe<Scalars['String']>;
  homepageEqualFold?: InputMaybe<Scalars['String']>;
  homepageGT?: InputMaybe<Scalars['String']>;
  homepageGTE?: InputMaybe<Scalars['String']>;
  homepageHasPrefix?: InputMaybe<Scalars['String']>;
  homepageHasSuffix?: InputMaybe<Scalars['String']>;
  homepageIn?: InputMaybe<Array<Scalars['String']>>;
  homepageIsNil?: InputMaybe<Scalars['Boolean']>;
  homepageLT?: InputMaybe<Scalars['String']>;
  homepageLTE?: InputMaybe<Scalars['String']>;
  homepageNEQ?: InputMaybe<Scalars['String']>;
  homepageNotIn?: InputMaybe<Array<Scalars['String']>>;
  homepageNotNil?: InputMaybe<Scalars['Boolean']>;
  /** html_url field predicates */
  htmlURL?: InputMaybe<Scalars['String']>;
  htmlURLContains?: InputMaybe<Scalars['String']>;
  htmlURLContainsFold?: InputMaybe<Scalars['String']>;
  htmlURLEqualFold?: InputMaybe<Scalars['String']>;
  htmlURLGT?: InputMaybe<Scalars['String']>;
  htmlURLGTE?: InputMaybe<Scalars['String']>;
  htmlURLHasPrefix?: InputMaybe<Scalars['String']>;
  htmlURLHasSuffix?: InputMaybe<Scalars['String']>;
  htmlURLIn?: InputMaybe<Array<Scalars['String']>>;
  htmlURLLT?: InputMaybe<Scalars['String']>;
  htmlURLLTE?: InputMaybe<Scalars['String']>;
  htmlURLNEQ?: InputMaybe<Scalars['String']>;
  htmlURLNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** is_template field predicates */
  isTemplate?: InputMaybe<Scalars['Boolean']>;
  isTemplateNEQ?: InputMaybe<Scalars['Boolean']>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<GithubRepositoryWhereInput>;
  or?: InputMaybe<Array<GithubRepositoryWhereInput>>;
  /** owner_login field predicates */
  ownerLogin?: InputMaybe<Scalars['String']>;
  ownerLoginContains?: InputMaybe<Scalars['String']>;
  ownerLoginContainsFold?: InputMaybe<Scalars['String']>;
  ownerLoginEqualFold?: InputMaybe<Scalars['String']>;
  ownerLoginGT?: InputMaybe<Scalars['String']>;
  ownerLoginGTE?: InputMaybe<Scalars['String']>;
  ownerLoginHasPrefix?: InputMaybe<Scalars['String']>;
  ownerLoginHasSuffix?: InputMaybe<Scalars['String']>;
  ownerLoginIn?: InputMaybe<Array<Scalars['String']>>;
  ownerLoginLT?: InputMaybe<Scalars['String']>;
  ownerLoginLTE?: InputMaybe<Scalars['String']>;
  ownerLoginNEQ?: InputMaybe<Scalars['String']>;
  ownerLoginNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** public field predicates */
  public?: InputMaybe<Scalars['Boolean']>;
  publicNEQ?: InputMaybe<Scalars['Boolean']>;
  /** pushed_at field predicates */
  pushedAt?: InputMaybe<Scalars['Time']>;
  pushedAtGT?: InputMaybe<Scalars['Time']>;
  pushedAtGTE?: InputMaybe<Scalars['Time']>;
  pushedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  pushedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  pushedAtLT?: InputMaybe<Scalars['Time']>;
  pushedAtLTE?: InputMaybe<Scalars['Time']>;
  pushedAtNEQ?: InputMaybe<Scalars['Time']>;
  pushedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  pushedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** repo_id field predicates */
  repoID?: InputMaybe<Scalars['Int']>;
  repoIDGT?: InputMaybe<Scalars['Int']>;
  repoIDGTE?: InputMaybe<Scalars['Int']>;
  repoIDIn?: InputMaybe<Array<Scalars['Int']>>;
  repoIDLT?: InputMaybe<Scalars['Int']>;
  repoIDLTE?: InputMaybe<Scalars['Int']>;
  repoIDNEQ?: InputMaybe<Scalars['Int']>;
  repoIDNotIn?: InputMaybe<Array<Scalars['Int']>>;
  /** star_count field predicates */
  starCount?: InputMaybe<Scalars['Int']>;
  starCountGT?: InputMaybe<Scalars['Int']>;
  starCountGTE?: InputMaybe<Scalars['Int']>;
  starCountIn?: InputMaybe<Array<Scalars['Int']>>;
  starCountLT?: InputMaybe<Scalars['Int']>;
  starCountLTE?: InputMaybe<Scalars['Int']>;
  starCountNEQ?: InputMaybe<Scalars['Int']>;
  starCountNotIn?: InputMaybe<Array<Scalars['Int']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtNotNil?: InputMaybe<Scalars['Boolean']>;
};

export type GithubUser = {
  __typename: 'GithubUser';
  avatarURL: Scalars['String'];
  bio?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Timestamp>;
  email?: Maybe<Scalars['String']>;
  followers?: Maybe<Scalars['Int']>;
  following?: Maybe<Scalars['Int']>;
  htmlurl?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  location?: Maybe<Scalars['String']>;
  login: Scalars['String'];
  name?: Maybe<Scalars['String']>;
  publicRepos?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Timestamp>;
};

export type Label = Node & {
  __typename: 'Label';
  createTime: Scalars['Time'];
  githubRepositories: GithubRepositoryConnection;
  id: Scalars['ID'];
  name: Scalars['String'];
  posts: PostConnection;
  updateTime: Scalars['Time'];
};


export type LabelGithubRepositoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<GithubRepositoryOrder>;
  where?: InputMaybe<GithubRepositoryWhereInput>;
};


export type LabelPostsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PostOrder>;
  where?: InputMaybe<PostWhereInput>;
};

/** A connection to a list of items. */
export type LabelConnection = {
  __typename: 'LabelConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LabelEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type LabelEdge = {
  __typename: 'LabelEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Label>;
};

/** Ordering options for Label connections */
export type LabelOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Labels. */
  field: LabelOrderField;
};

/** Properties by which Label connections can be ordered. */
export enum LabelOrderField {
  Name = 'NAME'
}

/**
 * LabelWhereInput is used for filtering Label objects.
 * Input was generated by ent.
 */
export type LabelWhereInput = {
  and?: InputMaybe<Array<LabelWhereInput>>;
  /** create_time field predicates */
  createTime?: InputMaybe<Scalars['Time']>;
  createTimeGT?: InputMaybe<Scalars['Time']>;
  createTimeGTE?: InputMaybe<Scalars['Time']>;
  createTimeIn?: InputMaybe<Array<Scalars['Time']>>;
  createTimeLT?: InputMaybe<Scalars['Time']>;
  createTimeLTE?: InputMaybe<Scalars['Time']>;
  createTimeNEQ?: InputMaybe<Scalars['Time']>;
  createTimeNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** github_repositories edge predicates */
  hasGithubRepositories?: InputMaybe<Scalars['Boolean']>;
  hasGithubRepositoriesWith?: InputMaybe<Array<GithubRepositoryWhereInput>>;
  /** posts edge predicates */
  hasPosts?: InputMaybe<Scalars['Boolean']>;
  hasPostsWith?: InputMaybe<Array<PostWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<LabelWhereInput>;
  or?: InputMaybe<Array<LabelWhereInput>>;
  /** update_time field predicates */
  updateTime?: InputMaybe<Scalars['Time']>;
  updateTimeGT?: InputMaybe<Scalars['Time']>;
  updateTimeGTE?: InputMaybe<Scalars['Time']>;
  updateTimeIn?: InputMaybe<Array<Scalars['Time']>>;
  updateTimeLT?: InputMaybe<Scalars['Time']>;
  updateTimeLTE?: InputMaybe<Scalars['Time']>;
  updateTimeNEQ?: InputMaybe<Scalars['Time']>;
  updateTimeNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type LanguageStat = {
  __typename: 'LanguageStat';
  language: Scalars['String'];
  totalDuration: Scalars['String'];
  totalSeconds: Scalars['Int'];
};

export type Link = {
  __typename: 'Link';
  name: Scalars['String'];
  url: Scalars['String'];
};

export type Mutation = {
  __typename: 'Mutation';
  createLabel: Label;
  createPost: Post;
  deleteLabel: Scalars['ID'];
  deletePost: Scalars['ID'];
  regeneratePosts: Scalars['Boolean'];
  updateLabel: Label;
  updatePost: Post;
};


export type MutationCreateLabelArgs = {
  input: CreateLabelInput;
};


export type MutationCreatePostArgs = {
  input: CreatePostInput;
};


export type MutationDeleteLabelArgs = {
  id: Scalars['ID'];
};


export type MutationDeletePostArgs = {
  id: Scalars['ID'];
};


export type MutationUpdateLabelArgs = {
  id: Scalars['ID'];
  input: UpdateLabelInput;
};


export type MutationUpdatePostArgs = {
  id: Scalars['ID'];
  input: UpdatePostInput;
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  __typename: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>;
};

export type Post = Node & {
  __typename: 'Post';
  author: User;
  content: Scalars['String'];
  contentHTML: Scalars['String'];
  createTime: Scalars['Time'];
  id: Scalars['ID'];
  labels: LabelConnection;
  public: Scalars['Boolean'];
  publishedAt: Scalars['Time'];
  slug: Scalars['String'];
  summary: Scalars['String'];
  title: Scalars['String'];
  updateTime: Scalars['Time'];
  viewCount: Scalars['Int'];
};


export type PostLabelsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<LabelOrder>;
  where?: InputMaybe<LabelWhereInput>;
};

/** A connection to a list of items. */
export type PostConnection = {
  __typename: 'PostConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PostEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type PostEdge = {
  __typename: 'PostEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Post>;
};

/** Ordering options for Post connections */
export type PostOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Posts. */
  field: PostOrderField;
};

/** Properties by which Post connections can be ordered. */
export enum PostOrderField {
  Date = 'DATE',
  Slug = 'SLUG',
  Title = 'TITLE',
  ViewCount = 'VIEW_COUNT'
}

/**
 * PostWhereInput is used for filtering Post objects.
 * Input was generated by ent.
 */
export type PostWhereInput = {
  and?: InputMaybe<Array<PostWhereInput>>;
  /** content field predicates */
  content?: InputMaybe<Scalars['String']>;
  contentContains?: InputMaybe<Scalars['String']>;
  contentContainsFold?: InputMaybe<Scalars['String']>;
  contentEqualFold?: InputMaybe<Scalars['String']>;
  contentGT?: InputMaybe<Scalars['String']>;
  contentGTE?: InputMaybe<Scalars['String']>;
  /** content_html field predicates */
  contentHTML?: InputMaybe<Scalars['String']>;
  contentHTMLContains?: InputMaybe<Scalars['String']>;
  contentHTMLContainsFold?: InputMaybe<Scalars['String']>;
  contentHTMLEqualFold?: InputMaybe<Scalars['String']>;
  contentHTMLGT?: InputMaybe<Scalars['String']>;
  contentHTMLGTE?: InputMaybe<Scalars['String']>;
  contentHTMLHasPrefix?: InputMaybe<Scalars['String']>;
  contentHTMLHasSuffix?: InputMaybe<Scalars['String']>;
  contentHTMLIn?: InputMaybe<Array<Scalars['String']>>;
  contentHTMLLT?: InputMaybe<Scalars['String']>;
  contentHTMLLTE?: InputMaybe<Scalars['String']>;
  contentHTMLNEQ?: InputMaybe<Scalars['String']>;
  contentHTMLNotIn?: InputMaybe<Array<Scalars['String']>>;
  contentHasPrefix?: InputMaybe<Scalars['String']>;
  contentHasSuffix?: InputMaybe<Scalars['String']>;
  contentIn?: InputMaybe<Array<Scalars['String']>>;
  contentLT?: InputMaybe<Scalars['String']>;
  contentLTE?: InputMaybe<Scalars['String']>;
  contentNEQ?: InputMaybe<Scalars['String']>;
  contentNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** create_time field predicates */
  createTime?: InputMaybe<Scalars['Time']>;
  createTimeGT?: InputMaybe<Scalars['Time']>;
  createTimeGTE?: InputMaybe<Scalars['Time']>;
  createTimeIn?: InputMaybe<Array<Scalars['Time']>>;
  createTimeLT?: InputMaybe<Scalars['Time']>;
  createTimeLTE?: InputMaybe<Scalars['Time']>;
  createTimeNEQ?: InputMaybe<Scalars['Time']>;
  createTimeNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** author edge predicates */
  hasAuthor?: InputMaybe<Scalars['Boolean']>;
  hasAuthorWith?: InputMaybe<Array<UserWhereInput>>;
  /** labels edge predicates */
  hasLabels?: InputMaybe<Scalars['Boolean']>;
  hasLabelsWith?: InputMaybe<Array<LabelWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<PostWhereInput>;
  or?: InputMaybe<Array<PostWhereInput>>;
  /** public field predicates */
  public?: InputMaybe<Scalars['Boolean']>;
  publicNEQ?: InputMaybe<Scalars['Boolean']>;
  /** published_at field predicates */
  publishedAt?: InputMaybe<Scalars['Time']>;
  publishedAtGT?: InputMaybe<Scalars['Time']>;
  publishedAtGTE?: InputMaybe<Scalars['Time']>;
  publishedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  publishedAtLT?: InputMaybe<Scalars['Time']>;
  publishedAtLTE?: InputMaybe<Scalars['Time']>;
  publishedAtNEQ?: InputMaybe<Scalars['Time']>;
  publishedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** slug field predicates */
  slug?: InputMaybe<Scalars['String']>;
  slugContains?: InputMaybe<Scalars['String']>;
  slugContainsFold?: InputMaybe<Scalars['String']>;
  slugEqualFold?: InputMaybe<Scalars['String']>;
  slugGT?: InputMaybe<Scalars['String']>;
  slugGTE?: InputMaybe<Scalars['String']>;
  slugHasPrefix?: InputMaybe<Scalars['String']>;
  slugHasSuffix?: InputMaybe<Scalars['String']>;
  slugIn?: InputMaybe<Array<Scalars['String']>>;
  slugLT?: InputMaybe<Scalars['String']>;
  slugLTE?: InputMaybe<Scalars['String']>;
  slugNEQ?: InputMaybe<Scalars['String']>;
  slugNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** summary field predicates */
  summary?: InputMaybe<Scalars['String']>;
  summaryContains?: InputMaybe<Scalars['String']>;
  summaryContainsFold?: InputMaybe<Scalars['String']>;
  summaryEqualFold?: InputMaybe<Scalars['String']>;
  summaryGT?: InputMaybe<Scalars['String']>;
  summaryGTE?: InputMaybe<Scalars['String']>;
  summaryHasPrefix?: InputMaybe<Scalars['String']>;
  summaryHasSuffix?: InputMaybe<Scalars['String']>;
  summaryIn?: InputMaybe<Array<Scalars['String']>>;
  summaryLT?: InputMaybe<Scalars['String']>;
  summaryLTE?: InputMaybe<Scalars['String']>;
  summaryNEQ?: InputMaybe<Scalars['String']>;
  summaryNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']>;
  titleContains?: InputMaybe<Scalars['String']>;
  titleContainsFold?: InputMaybe<Scalars['String']>;
  titleEqualFold?: InputMaybe<Scalars['String']>;
  titleGT?: InputMaybe<Scalars['String']>;
  titleGTE?: InputMaybe<Scalars['String']>;
  titleHasPrefix?: InputMaybe<Scalars['String']>;
  titleHasSuffix?: InputMaybe<Scalars['String']>;
  titleIn?: InputMaybe<Array<Scalars['String']>>;
  titleLT?: InputMaybe<Scalars['String']>;
  titleLTE?: InputMaybe<Scalars['String']>;
  titleNEQ?: InputMaybe<Scalars['String']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** update_time field predicates */
  updateTime?: InputMaybe<Scalars['Time']>;
  updateTimeGT?: InputMaybe<Scalars['Time']>;
  updateTimeGTE?: InputMaybe<Scalars['Time']>;
  updateTimeIn?: InputMaybe<Array<Scalars['Time']>>;
  updateTimeLT?: InputMaybe<Scalars['Time']>;
  updateTimeLTE?: InputMaybe<Scalars['Time']>;
  updateTimeNEQ?: InputMaybe<Scalars['Time']>;
  updateTimeNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** view_count field predicates */
  viewCount?: InputMaybe<Scalars['Int']>;
  viewCountGT?: InputMaybe<Scalars['Int']>;
  viewCountGTE?: InputMaybe<Scalars['Int']>;
  viewCountIn?: InputMaybe<Array<Scalars['Int']>>;
  viewCountLT?: InputMaybe<Scalars['Int']>;
  viewCountLTE?: InputMaybe<Scalars['Int']>;
  viewCountNEQ?: InputMaybe<Scalars['Int']>;
  viewCountNotIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type Query = {
  __typename: 'Query';
  codingStats: CodingStats;
  githubUser: GithubUser;
  githubevents: GithubEventConnection;
  githubrepositories: GithubRepositoryConnection;
  labels: LabelConnection;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  posts: PostConnection;
  self?: Maybe<User>;
  users: UserConnection;
  version: VersionInfo;
};


export type QueryGithubeventsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<GithubEventOrder>;
  where?: InputMaybe<GithubEventWhereInput>;
};


export type QueryGithubrepositoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<GithubRepositoryOrder>;
  where?: InputMaybe<GithubRepositoryWhereInput>;
};


export type QueryLabelsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<LabelOrder>;
  where?: InputMaybe<LabelWhereInput>;
};


export type QueryNodeArgs = {
  id: Scalars['ID'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']>;
};


export type QueryPostsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PostOrder>;
  where?: InputMaybe<PostWhereInput>;
};


export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<UserOrder>;
  where?: InputMaybe<UserWhereInput>;
};

export type Timestamp = {
  __typename: 'Timestamp';
  Time: Scalars['Time'];
};

/**
 * UpdateLabelInput is used for update Label object.
 * Input was generated by ent.
 */
export type UpdateLabelInput = {
  addGithubRepositoryIDs?: InputMaybe<Array<Scalars['ID']>>;
  addPostIDs?: InputMaybe<Array<Scalars['ID']>>;
  name?: InputMaybe<Scalars['String']>;
  removeGithubRepositoryIDs?: InputMaybe<Array<Scalars['ID']>>;
  removePostIDs?: InputMaybe<Array<Scalars['ID']>>;
  updateTime?: InputMaybe<Scalars['Time']>;
};

/**
 * UpdatePostInput is used for update Post object.
 * Input was generated by ent.
 */
export type UpdatePostInput = {
  addLabelIDs?: InputMaybe<Array<Scalars['ID']>>;
  content?: InputMaybe<Scalars['String']>;
  public?: InputMaybe<Scalars['Boolean']>;
  publishedAt?: InputMaybe<Scalars['Time']>;
  removeLabelIDs?: InputMaybe<Array<Scalars['ID']>>;
  slug?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  updateTime?: InputMaybe<Scalars['Time']>;
};

export type User = Node & {
  __typename: 'User';
  avatarURL?: Maybe<Scalars['String']>;
  bio?: Maybe<Scalars['String']>;
  createTime: Scalars['Time'];
  email?: Maybe<Scalars['String']>;
  htmlURL?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  location?: Maybe<Scalars['String']>;
  login: Scalars['String'];
  name?: Maybe<Scalars['String']>;
  posts: PostConnection;
  updateTime: Scalars['Time'];
  userID: Scalars['Int'];
};


export type UserPostsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<PostOrder>;
  where?: InputMaybe<PostWhereInput>;
};

/** A connection to a list of items. */
export type UserConnection = {
  __typename: 'UserConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type UserEdge = {
  __typename: 'UserEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

/** Ordering options for User connections */
export type UserOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Users. */
  field: UserOrderField;
};

/** Properties by which User connections can be ordered. */
export enum UserOrderField {
  Email = 'EMAIL',
  Login = 'LOGIN',
  Name = 'NAME'
}

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  and?: InputMaybe<Array<UserWhereInput>>;
  /** avatar_url field predicates */
  avatarURL?: InputMaybe<Scalars['String']>;
  avatarURLContains?: InputMaybe<Scalars['String']>;
  avatarURLContainsFold?: InputMaybe<Scalars['String']>;
  avatarURLEqualFold?: InputMaybe<Scalars['String']>;
  avatarURLGT?: InputMaybe<Scalars['String']>;
  avatarURLGTE?: InputMaybe<Scalars['String']>;
  avatarURLHasPrefix?: InputMaybe<Scalars['String']>;
  avatarURLHasSuffix?: InputMaybe<Scalars['String']>;
  avatarURLIn?: InputMaybe<Array<Scalars['String']>>;
  avatarURLIsNil?: InputMaybe<Scalars['Boolean']>;
  avatarURLLT?: InputMaybe<Scalars['String']>;
  avatarURLLTE?: InputMaybe<Scalars['String']>;
  avatarURLNEQ?: InputMaybe<Scalars['String']>;
  avatarURLNotIn?: InputMaybe<Array<Scalars['String']>>;
  avatarURLNotNil?: InputMaybe<Scalars['Boolean']>;
  /** bio field predicates */
  bio?: InputMaybe<Scalars['String']>;
  bioContains?: InputMaybe<Scalars['String']>;
  bioContainsFold?: InputMaybe<Scalars['String']>;
  bioEqualFold?: InputMaybe<Scalars['String']>;
  bioGT?: InputMaybe<Scalars['String']>;
  bioGTE?: InputMaybe<Scalars['String']>;
  bioHasPrefix?: InputMaybe<Scalars['String']>;
  bioHasSuffix?: InputMaybe<Scalars['String']>;
  bioIn?: InputMaybe<Array<Scalars['String']>>;
  bioIsNil?: InputMaybe<Scalars['Boolean']>;
  bioLT?: InputMaybe<Scalars['String']>;
  bioLTE?: InputMaybe<Scalars['String']>;
  bioNEQ?: InputMaybe<Scalars['String']>;
  bioNotIn?: InputMaybe<Array<Scalars['String']>>;
  bioNotNil?: InputMaybe<Scalars['Boolean']>;
  /** create_time field predicates */
  createTime?: InputMaybe<Scalars['Time']>;
  createTimeGT?: InputMaybe<Scalars['Time']>;
  createTimeGTE?: InputMaybe<Scalars['Time']>;
  createTimeIn?: InputMaybe<Array<Scalars['Time']>>;
  createTimeLT?: InputMaybe<Scalars['Time']>;
  createTimeLTE?: InputMaybe<Scalars['Time']>;
  createTimeNEQ?: InputMaybe<Scalars['Time']>;
  createTimeNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']>;
  emailContains?: InputMaybe<Scalars['String']>;
  emailContainsFold?: InputMaybe<Scalars['String']>;
  emailEqualFold?: InputMaybe<Scalars['String']>;
  emailGT?: InputMaybe<Scalars['String']>;
  emailGTE?: InputMaybe<Scalars['String']>;
  emailHasPrefix?: InputMaybe<Scalars['String']>;
  emailHasSuffix?: InputMaybe<Scalars['String']>;
  emailIn?: InputMaybe<Array<Scalars['String']>>;
  emailIsNil?: InputMaybe<Scalars['Boolean']>;
  emailLT?: InputMaybe<Scalars['String']>;
  emailLTE?: InputMaybe<Scalars['String']>;
  emailNEQ?: InputMaybe<Scalars['String']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']>>;
  emailNotNil?: InputMaybe<Scalars['Boolean']>;
  /** posts edge predicates */
  hasPosts?: InputMaybe<Scalars['Boolean']>;
  hasPostsWith?: InputMaybe<Array<PostWhereInput>>;
  /** html_url field predicates */
  htmlURL?: InputMaybe<Scalars['String']>;
  htmlURLContains?: InputMaybe<Scalars['String']>;
  htmlURLContainsFold?: InputMaybe<Scalars['String']>;
  htmlURLEqualFold?: InputMaybe<Scalars['String']>;
  htmlURLGT?: InputMaybe<Scalars['String']>;
  htmlURLGTE?: InputMaybe<Scalars['String']>;
  htmlURLHasPrefix?: InputMaybe<Scalars['String']>;
  htmlURLHasSuffix?: InputMaybe<Scalars['String']>;
  htmlURLIn?: InputMaybe<Array<Scalars['String']>>;
  htmlURLIsNil?: InputMaybe<Scalars['Boolean']>;
  htmlURLLT?: InputMaybe<Scalars['String']>;
  htmlURLLTE?: InputMaybe<Scalars['String']>;
  htmlURLNEQ?: InputMaybe<Scalars['String']>;
  htmlURLNotIn?: InputMaybe<Array<Scalars['String']>>;
  htmlURLNotNil?: InputMaybe<Scalars['Boolean']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** location field predicates */
  location?: InputMaybe<Scalars['String']>;
  locationContains?: InputMaybe<Scalars['String']>;
  locationContainsFold?: InputMaybe<Scalars['String']>;
  locationEqualFold?: InputMaybe<Scalars['String']>;
  locationGT?: InputMaybe<Scalars['String']>;
  locationGTE?: InputMaybe<Scalars['String']>;
  locationHasPrefix?: InputMaybe<Scalars['String']>;
  locationHasSuffix?: InputMaybe<Scalars['String']>;
  locationIn?: InputMaybe<Array<Scalars['String']>>;
  locationIsNil?: InputMaybe<Scalars['Boolean']>;
  locationLT?: InputMaybe<Scalars['String']>;
  locationLTE?: InputMaybe<Scalars['String']>;
  locationNEQ?: InputMaybe<Scalars['String']>;
  locationNotIn?: InputMaybe<Array<Scalars['String']>>;
  locationNotNil?: InputMaybe<Scalars['Boolean']>;
  /** login field predicates */
  login?: InputMaybe<Scalars['String']>;
  loginContains?: InputMaybe<Scalars['String']>;
  loginContainsFold?: InputMaybe<Scalars['String']>;
  loginEqualFold?: InputMaybe<Scalars['String']>;
  loginGT?: InputMaybe<Scalars['String']>;
  loginGTE?: InputMaybe<Scalars['String']>;
  loginHasPrefix?: InputMaybe<Scalars['String']>;
  loginHasSuffix?: InputMaybe<Scalars['String']>;
  loginIn?: InputMaybe<Array<Scalars['String']>>;
  loginLT?: InputMaybe<Scalars['String']>;
  loginLTE?: InputMaybe<Scalars['String']>;
  loginNEQ?: InputMaybe<Scalars['String']>;
  loginNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameIsNil?: InputMaybe<Scalars['Boolean']>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  nameNotNil?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<UserWhereInput>;
  or?: InputMaybe<Array<UserWhereInput>>;
  /** update_time field predicates */
  updateTime?: InputMaybe<Scalars['Time']>;
  updateTimeGT?: InputMaybe<Scalars['Time']>;
  updateTimeGTE?: InputMaybe<Scalars['Time']>;
  updateTimeIn?: InputMaybe<Array<Scalars['Time']>>;
  updateTimeLT?: InputMaybe<Scalars['Time']>;
  updateTimeLTE?: InputMaybe<Scalars['Time']>;
  updateTimeNEQ?: InputMaybe<Scalars['Time']>;
  updateTimeNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** user_id field predicates */
  userID?: InputMaybe<Scalars['Int']>;
  userIDGT?: InputMaybe<Scalars['Int']>;
  userIDGTE?: InputMaybe<Scalars['Int']>;
  userIDIn?: InputMaybe<Array<Scalars['Int']>>;
  userIDLT?: InputMaybe<Scalars['Int']>;
  userIDLTE?: InputMaybe<Scalars['Int']>;
  userIDNEQ?: InputMaybe<Scalars['Int']>;
  userIDNotIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type VersionInfo = {
  __typename: 'VersionInfo';
  arch: Scalars['String'];
  command: Scalars['String'];
  commit: Scalars['String'];
  date: Scalars['String'];
  goVersion: Scalars['String'];
  links?: Maybe<Array<Link>>;
  name: Scalars['String'];
  os: Scalars['String'];
  version: Scalars['String'];
};

export type CreateLabelMutationVariables = Exact<{
  input: CreateLabelInput;
}>;


export type CreateLabelMutation = { createLabel: { __typename: 'Label', id: string, name: string } };

export type CreatePostMutationVariables = Exact<{
  input: CreatePostInput;
}>;


export type CreatePostMutation = { createPost: { __typename: 'Post', id: string } };

export type BaseQueryVariables = Exact<{ [key: string]: never; }>;


export type BaseQuery = { self?: { __typename: 'User', id: string, name?: string | null, login: string, avatarURL?: string | null } | null, githubUser: { __typename: 'GithubUser', login: string, name?: string | null, avatarURL: string, bio?: string | null, email?: string | null, location?: string | null, htmlurl?: string | null }, version: { __typename: 'VersionInfo', commit: string, goVersion: string, date: string }, codingStats: { __typename: 'CodingStats', totalDuration: string, totalSeconds: number, calculatedDays: number, languages?: Array<{ __typename: 'LanguageStat', language: string, totalSeconds: number }> | null } };

export type GetEventsQueryVariables = Exact<{
  count?: InputMaybe<Scalars['Int']>;
  cursor?: InputMaybe<Scalars['Cursor']>;
  order?: InputMaybe<OrderDirection>;
  orderBy?: InputMaybe<GithubEventOrderField>;
}>;


export type GetEventsQuery = { githubevents: { __typename: 'GithubEventConnection', edges?: Array<{ __typename: 'GithubEventEdge', node?: { __typename: 'GithubEvent', id: string, eventType: string, createdAt: any, payload: any, actor: { __typename: 'GithubUser', login: string, avatarURL: string }, repo: { __typename: 'GithubEventRepo', name: string } } | null } | null> | null, pageInfo: { __typename: 'PageInfo', hasNextPage: boolean, endCursor?: any | null } } };

export type GetPostsQueryVariables = Exact<{
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  before?: InputMaybe<Scalars['Cursor']>;
  after?: InputMaybe<Scalars['Cursor']>;
  order?: InputMaybe<OrderDirection>;
  orderBy?: InputMaybe<PostOrderField>;
  where?: InputMaybe<PostWhereInput>;
}>;


export type GetPostsQuery = { posts: { __typename: 'PostConnection', edges?: Array<{ __typename: 'PostEdge', node?: { __typename: 'Post', id: string, title: string, summary: string, slug: string, public: boolean, publishedAt: any, viewCount: number, labels: { __typename: 'LabelConnection', edges?: Array<{ __typename: 'LabelEdge', node?: { __typename: 'Label', id: string, name: string } | null } | null> | null }, author: { __typename: 'User', name?: string | null, login: string, avatarURL?: string | null, htmlURL?: string | null } } | null } | null> | null, pageInfo: { __typename: 'PageInfo', hasNextPage: boolean, hasPreviousPage: boolean, startCursor?: any | null, endCursor?: any | null } } };

export type GetLabelsQueryVariables = Exact<{
  where?: InputMaybe<LabelWhereInput>;
}>;


export type GetLabelsQuery = { labels: { __typename: 'LabelConnection', edges?: Array<{ __typename: 'LabelEdge', node?: { __typename: 'Label', id: string, name: string, posts: { __typename: 'PostConnection', totalCount: number } } | null } | null> | null } };

export type GetPostContentQueryVariables = Exact<{
  slug: Scalars['String'];
}>;


export type GetPostContentQuery = { posts: { __typename: 'PostConnection', edges?: Array<{ __typename: 'PostEdge', node?: { __typename: 'Post', id: string, title: string, slug: string, content: string, contentHTML: string, viewCount: number, public: boolean, publishedAt: any, author: { __typename: 'User', name?: string | null, login: string, avatarURL?: string | null, htmlURL?: string | null }, labels: { __typename: 'LabelConnection', edges?: Array<{ __typename: 'LabelEdge', node?: { __typename: 'Label', id: string, name: string } | null } | null> | null } } | null } | null> | null } };
